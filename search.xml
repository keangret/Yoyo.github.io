<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker入门</title>
      <link href="/2024/04/15/Docker/"/>
      <url>/2024/04/15/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1.Docker简介"></a>1.Docker简介</h1><p>Docker是一个用于<strong>构建</strong>、<strong>运行</strong>、<strong>传送</strong>应用程序的平台，有了Docker,我们可以将应用程序和它运行时所需要的各种依赖包、第三方软件库、配置文件等打包在一起，以便在任何环境中都可以正确地运行。</p><h1 id="2-为什么使用Docker"><a href="#2-为什么使用Docker" class="headerlink" title="2.为什么使用Docker"></a>2.为什么使用Docker</h1><p>举一个例子，写一个网站需要用前后端分离架构，前端使用Vue框架构建网站界面，后端使用JAVA中的SpringBoot微服务架构来提供各种服务和接口，使用MYSQL数据库存储数据。如果没有Docker,需要在本地安装NodeJS环境，各种npm依赖，JAVA运行时环境，各种第三方依赖等，才能让网站运行。并且将项目部署到测试环境或生产环境上，则需要在新的环境重复以上操作，这样浪费大量了的时间。有了Docker，就可以将上面的东西打包成一个个集装箱，只要在开发环境中运行成功，那么在其他环境也能运行成功。</p><h1 id="3-Docker和虚拟机的区别"><a href="#3-Docker和虚拟机的区别" class="headerlink" title="3.Docker和虚拟机的区别"></a>3.Docker和虚拟机的区别</h1><h2 id="1-虚拟机"><a href="#1-虚拟机" class="headerlink" title="1.虚拟机"></a>1.虚拟机</h2><p>VMware、vittalbox、paralels desktop、WSL等是常见的虚拟机软件。在上面运行的系统是完整的操作系统，和实际的Windows和Linux系统一样，可以在这个操作系统中运行应用程序。这是通过一种叫虚拟化（Hypervior）的技术来实现的。虚拟化技术是一种将物理资源虚拟为多个逻辑资源的技术，它可以将一台物理服务器虚拟成多个逻辑服务器，每个逻辑服务器都有自己的操作系统、cpu、内存、硬盘和网络接口等。他们之间是完全隔离的，可以独立运行。虚拟机一定程度上实现了资源的整合。可以将一台服务器的计算能力、存储能力、网络资源分配给多个逻辑服务器，实现多台服务器的功能。但是，它的缺点很明显，每台虚拟机都需要占用大量的资源，而且启动速度非常慢，通常需要几分钟甚至几十分钟。大部分情况下，我们的一台服务器上只需要运行一个主要对外提供服务的应用程序即可，并不需要一个完整的操作系统所提供的所有功能。拿刚刚的例子来说，我们只需要一个web服务器，而虚拟机要启动一个完整的操作系统，包括操作系统的内核，各种系统服务，各种工具，甚至图形化界面等等。这样我们并不需要的服务占用了大量的资源。导致了资源的浪费和启动速度慢的问题。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/virtual_machine.png" alt="虚拟机" title="虚拟机"></p><h2 id="2-Docker"><a href="#2-Docker" class="headerlink" title="2.Docker"></a>2.Docker</h2><p>Docker和容器是两个不同的概念，Docker只是容器的一种实现，是一个容器化的解决方案和平台。容器是一种虚拟化技术，和虚拟机类似，也是一个独立的环境，可以在这个环境中运行应用程序。和虚拟机不同的是，它并不需要在容器中运行一个完整的操作系统，而是使用宿主机的操作系统，所有启动速度非常快，通常只需要几秒，同时所需要的资源更少，可以在一台物理服务器上运行更多的容器，这样可以跟家充分的利用服务器的资源，减少资源的闲置和浪费。比如我们的一台物理服务器可能只能运行几个虚拟机，但是却可以运行上百个容器，这就是容器和虚拟机的主要区别。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/docker.png" alt="Docker" title="docker"></p><h1 id="4-基本原理和概念"><a href="#4-基本原理和概念" class="headerlink" title="4.基本原理和概念"></a>4.基本原理和概念</h1><p>先介绍Docker的镜像、容器和仓库。镜像是一个只读的模板，它可以用来创建容器，容器是Docker的运行实例，它提供了一个独立的可移植的环境，可以在这个环境中运行应用程序，镜像和容器的关系就像JAVA中的类和实例的关系一样，我们可以定义一个类中有哪些属性和方法，这个定义好的类就是一个模板，我们可以根据这个模板来创建多个实例，这些实例就是这个类的对象，对应到Docker中，镜像就是一个模板，容器就是这个模板的一个实例，可以有一个，也可以有多个。在举个生活的例子，镜像就像一个食谱，详细的描述了如何制作一道菜肴，容器就是根据食谱做出来的那道菜，你可以根据这个食谱做出很多到菜，但是这些菜都是根据同一个食谱做出来的，做出来的菜都是一样的。而且也可以把食谱分享给其他喜欢美食的朋友，那他也可以根据这个食谱做出一道一样的菜来，这就是镜像和容器的关系。食谱如何分享给别人呢，这就要看第三个概念————Docker仓库。<br>Docker仓库是用来存储Docker镜像的地方，最流行和最常用的仓库就是Dockerhub，它是一个公共的仓库，用来集中存储和管理Docker镜像，我们可以在这里下载各种镜像，也可以将自己的镜像上传到这里，这样就可以实现镜像的共享和复用，这也是Docker非常流行的一个原因。拿刚刚的例子来说，如果你发明了一道非常美味的菜肴，那么就可以把这个食谱放到Dockerhub上，这样其他人可以根据食谱做出一样的菜，这就是镜像的共享和复用。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/principleandconcept.png" alt="Docker" title="docker的基本原理和概念"><br>Docker是使用Client-Server架构模式，Docker Client和Docker Daemon之间通过socket或者RESTful API进行通信，Docker Daemon就是服务器的守护进程，他负责管理Docker的各种资源，Docker Client负责向Docker Daemon发生请求，Docker Daemon接收到请求之后进行处理，然后将结果返回给Docker Client，这里的Docker Daemon是一个后台进程，用来接收并处理来自Docker客户端的请求，然后将结果返回给客户端，所以我们在终端中输入的各种Docker命令，实际上都是通过Docker客户端，发送给Docker Daemon的，然后Docker Daemon进行处理，最后再将结果返回给客户端，然后就可以在客户端看到执行结果了。</p><h1 id="5-容器化和Dockerfile"><a href="#5-容器化和Dockerfile" class="headerlink" title="5.容器化和Dockerfile"></a>5.容器化和Dockerfile</h1><p>容器化（containerization），顾名思义就是将应用程序打包成容器，然后在容器中运行应用程序的过程。这个过程可以简单分成三部分:</p><ul><li><p>创建一个Dockerfile。来告诉Docker构建应用程序镜像所需要的步骤和配置。</p></li><li><p>使用Dockerfile构建镜像。</p></li><li><p>使用镜像创建个运行容器。</p></li></ul><p>什么是Dockerfile，Dockerfile是一个文本文件，里面包含了一条条指令，用来告诉Docker如何来构建镜像，这个镜像中包括了我们应用程序执行的所有命令，也就我们之前提到的各种依赖，配置环境，和运行应用程序所需要的所有内容，一般来说包括下面这些内容。精简版的操作系统，比如Alpine,应用程序的运行时环境，比如Nodejs,java,python,应用程序，比如SpringBoot打包好的jar包，应用程序的第三方依赖库或者包，应用程序的配置文件，环境变量等等。一般来说，我们会在根目录下创建一个叫Dockerfile的文件，在这个文件中写入构建镜像所需要的各种指令后，Docker就会根据这个Dockerfile文件来构建一个镜像，有了镜像后，我们就可以使用这个镜像来创建容器，然后在容器中运行应用程序。</p><h1 id="6-实践操作"><a href="#6-实践操作" class="headerlink" title="6.实践操作"></a>6.实践操作</h1><p>以下为简单的案例，实机演示一下编写Dockerfile,创建镜像，启动容器的过程。</p><h2 id="1-在桌面上创建一个文件夹HelloDocker"><a href="#1-在桌面上创建一个文件夹HelloDocker" class="headerlink" title="1.在桌面上创建一个文件夹HelloDocker"></a>1.在桌面上创建一个文件夹HelloDocker</h2><h2 id="2-然后使用VScode等编辑器打开这个文件夹"><a href="#2-然后使用VScode等编辑器打开这个文件夹" class="headerlink" title="2.然后使用VScode等编辑器打开这个文件夹"></a>2.然后使用VScode等编辑器打开这个文件夹</h2><h2 id="3-在文件夹中创建一个index-js文件"><a href="#3-在文件夹中创建一个index-js文件" class="headerlink" title="3.在文件夹中创建一个index.js文件"></a>3.在文件夹中创建一个index.js文件</h2><h2 id="4-在文件中输入一段代码-并在终端运行"><a href="#4-在文件中输入一段代码-并在终端运行" class="headerlink" title="4.在文件中输入一段代码,并在终端运行"></a>4.在文件中输入一段代码,并在终端运行</h2><p>nodejs是一个运行时环境，它可以让我们在浏览器之外的地方运行javascript代码，nodejs和javascript的关系和java和JRE的关系一样，如果想运行java程序，那么就需要安装JRE.所有我们想在另外一个环境中运行这个应用程序都需要执行哪些步骤呢。<br>首先我们在这个环境中安装操作系统。然后安装对应版本的javascript运行环境，也就是nodejs。再把应用程序和它所依赖的第三方包和库复制到这个环境上，最后执行命令运行程序有了Docker后，我们就可以把这些步骤写入Dockerfile中，剩下的工作交给Docker来自动完成。<br>下面的代码是在控制台打印文字<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;欢迎来到一小时Docker教程，拜托一键三连了&quot;)</span><br></pre></td></tr></table></figure><br>下面指令是在vscode终端执行index.js文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><br>终端运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/command1.png" alt="command1" title="node index.js的运行"></p><h2 id="5-在根目录创建一个Dockerfile的文件"><a href="#5-在根目录创建一个Dockerfile的文件" class="headerlink" title="5.在根目录创建一个Dockerfile的文件"></a>5.在根目录创建一个Dockerfile的文件</h2><p>主要第一个字母D要大写，否则无法识别。并且vscode下载Docker扩展。</p><h2 id="6-在Docker指定一个基础镜像"><a href="#6-在Docker指定一个基础镜像" class="headerlink" title="6.在Docker指定一个基础镜像"></a>6.在Docker指定一个基础镜像</h2><p>镜像是按层次结构构建的，每一次都是基于上一层的，所有我们需要先指定一个基础镜像，然后在这个基础上添加我们的应用程序。<br>下面代码是指定一个基础镜像<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM node:20-alpine</span><br></pre></td></tr></table></figure><br>20表示nodejs版本，alpine表示这个镜像是基于alpine这个linux发行版来构建的，alpine和其他我们经常听说的RedHat,Centos一样，都是一种linux发行版，只不过它是一个非常轻量级的linux发行版，体积非常小，只有几十M，所有下载和部署都非常快，配置完运行环境后，还需要把应用程序复制到镜像中。可以使用copy命令复制文件。<br>代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//COPY source destination</span><br><span class="line">COPY index.js /index.js</span><br></pre></td></tr></table></figure><br>然后运行应用程序，使用CMD命令运行，CMD第一个参数表示可执行程序的名字，第二个参数表示可执行程序接收到的参数。<br>代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;node&quot; ,&quot;/index.js&quot;]</span><br></pre></td></tr></table></figure><br>index.js所有代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM node:20-alpine</span><br><span class="line">COPY index.js /index.js</span><br><span class="line">CMD [ &quot;node&quot; ,&quot;/index.js&quot;]</span><br></pre></td></tr></table></figure></p><h2 id="7-构建镜像"><a href="#7-构建镜像" class="headerlink" title="7.构建镜像"></a>7.构建镜像</h2><p>到vscode终端使用docker build -t hello-docker .命令来构建镜像,.为Dockerfile所在目录<br>命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hello-docker  .</span><br></pre></td></tr></table></figure><br>终端运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/command2.png" alt="command2" title="镜像的构建"><br>使用docker image ls命令来查看我们所有的镜像，我们可以在控制台看到我创建的镜像。<br>命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><br>终端运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/command3.png" alt="command3" title="查看镜像"></p><h2 id="8-运行"><a href="#8-运行" class="headerlink" title="8.运行"></a>8.运行</h2><p>使用docker run hello-docker命令,hello-docker为刚刚构建的镜像名字<br>命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-docker</span><br></pre></td></tr></table></figure><br>终端运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/command4.png" alt="command4" title="运行"><br>在控制台中出现了我们输入的内容，说明应用程序已经运行起来了。如果想在另一个环境中运行这个应用程序，那么就只需要把这个镜像文件复制过去，然后执行上面的命令即可。也可以把镜像文件上传到Dockerhub或者Harbor镜像仓库中，这样任何人都可以在任何地方使用docker pull命令下载这个镜像，然后运行这个应用程序。</p><h1 id="7-Docker-Desktop"><a href="#7-Docker-Desktop" class="headerlink" title="7.Docker Desktop"></a>7.Docker Desktop</h1><h2 id="1-images界面"><a href="#1-images界面" class="headerlink" title="1.images界面"></a>1.images界面</h2><p>点击镜像（images）后，可以看到镜像的名称、标称、状态等信息，点击播放按钮可以使用这个镜像运行一个容器了，也就相当于在终端执行docker run命令。后面三个小点表示更多操作，点击后弹出一个菜单。第一项查看这个镜像包的详细信息，第二和第三项是镜像的远程仓库相关操作，也就是从远程仓库拉取镜像或者推送镜像到远程仓库中，这两个功能需要登录账号。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/image_operate.png" alt="images" title="images界面"></p><h2 id="2-containers界面"><a href="#2-containers界面" class="headerlink" title="2.containers界面"></a>2.containers界面</h2><p>点击容器（containers）后，与镜像一样，可以查看容器的信息，操作与镜像基本一致。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/containers.png" alt="containers" title="containers界面"></p><h2 id="3-volumes界面"><a href="#3-volumes界面" class="headerlink" title="3.volumes界面"></a>3.volumes界面</h2><p>逻辑卷界面，逻辑卷是Docker中用来存储数据的，Docker容器有一个特点，就是容器中的数据不会持久化的，当我们创建一个容器的时候，它通常已一个干净的文件系统开始，容器启动后，我们可以在容器中创建文件，修改文件，但是容器停止后，容器中的所有数据都会丢失掉，如果我们想持久化容器中的数据，就需要依靠逻辑卷。它可以把容器中的目录或者指定路径映射到宿主机的某一个目录或者位置上，这样就可以将数据保存带宿主机的磁盘上，实现数据的持久化。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/Volumes.png" alt="volumes" title="volumes界面"></p><h2 id="4-Dev-Environments-BETA"><a href="#4-Dev-Environments-BETA" class="headerlink" title="4.Dev Environments BETA"></a>4.Dev Environments BETA</h2><p>该界面用来管理开发环境的，我们可以在这创建一个开发环境，然后使用一些代码来配置这个开发环境，这样就可以把这个开发环境共享给项目中的其他开发人员，让每一个人在同一个环境下进行开发。避免环境不一致导致的各种问题。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/dev_environments.png" alt="Dev Environments BETA" title="dev_environments界面"></p><h2 id="5-Learning-Center"><a href="#5-Learning-Center" class="headerlink" title="5.Learning Center"></a>5.Learning Center</h2><p>官方提供的学习视频和教程。</p><h2 id="6-Add-Extensioning"><a href="#6-Add-Extensioning" class="headerlink" title="6.Add Extensioning"></a>6.Add Extensioning</h2><p>可以安装一些扩展来增强它的功能。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/add_extensions.png" alt="add_extensioning" title="add extensioning界面"></p><h1 id="8-Docker-Compose"><a href="#8-Docker-Compose" class="headerlink" title="8.Docker Compose"></a>8.Docker Compose</h1><p>Docker Compose是由Docker官方开源的项目，是一个用来定义和运行多容器Docker应用程序的工具。比如之前搭建网站的案例，可能会使用前端、后端、数据库甚至缓存、负载均衡等多个服务器。这些服务都是独立的，但是之间又有关联，需要相互配合来工作，Docker Compose通过一个单独的docker-compose.yaml的配置文件，来将这一组互相关联的容器组合在一起，形成一个项目，然后使用一条命令启动、停止或者重建这些服务，这样就可以非常方便的管理这些服务了。举个例子，假如项目组中来了一个新同事，之前可能需要半天时间安装各种依赖和配置运行环境，有了Docker Compose后，只需要执行docker compose up命令，就可以自动安装各种依赖和配置运行环境。然后再本地运行项目了。</p><p>本文根据youtube平台，GeekHour教程所写，域名为<a href="https://www.youtube.com/watch?v=Ozb9mZg7MVM，访问请">https://www.youtube.com/watch?v=Ozb9mZg7MVM，访问请</a> <a href="https://www.youtube.com/watch?v=Ozb9mZg7MVM" title="30分钟Docker入门教程">点击此处</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><div class="note default simple"><p>内容…….</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第三篇文章"><a href="#这是我的第三篇文章" class="headerlink" title="这是我的第三篇文章"></a>这是我的第三篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第二篇文章"><a href="#这是我的第二篇文章" class="headerlink" title="这是我的第二篇文章"></a>这是我的第二篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第五篇文章"><a href="#这是我的第五篇文章" class="headerlink" title="这是我的第五篇文章"></a>这是我的第五篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第二篇文章"><a href="#这是我的第二篇文章" class="headerlink" title="这是我的第二篇文章"></a>这是我的第二篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第四篇文章"><a href="#这是我的第四篇文章" class="headerlink" title="这是我的第四篇文章"></a>这是我的第四篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签4 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
