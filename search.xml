<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>有序数组的平方</title>
      <link href="/2024/04/19/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2024/04/19/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="1-要求"><a href="#1-要求" class="headerlink" title="1.要求"></a>1.要求</h1><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按<strong>非递减顺序</strong>排序。</p><h1 id="2-暴力排序"><a href="#2-暴力排序" class="headerlink" title="2.暴力排序"></a>2.暴力排序</h1><p>代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; sortedSquares_violent_solutions(vector&lt;int&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">nums[i] = nums[i] * nums[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">sort(nums.begin(), nums.end());//快速排序</span><br><span class="line">return nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个时间复杂度是 O(n + nlogn)， 可以说是O(nlogn)的时间复杂度，但为了和下面双指针法算法时间复杂度有鲜明对比，我记为 O(n + nlog n)。</p><h1 id="3-双指针法"><a href="#3-双指针法" class="headerlink" title="3.双指针法"></a>3.双指针法</h1><p>由于数组有序，那么平方的最大值在数组的两端，不是左边就是右边，不可能是中间。这是可以用双指针发，i指向其实位置，j指向终止位置。先定义一个result数组，与Nums数组一样大小，让k指向result数组终止位置。<br>这里为什么要用i&lt;=j呢，如果没有=，那么i=j时，循环直接退出，这样的话新数组无法更新i=j时的数据，就把这个元素拉下了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nums5 = &#123; -5,-3,0,2,5,6 &#125;;</span><br><span class="line">vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">int k = nums.size()-1;</span><br><span class="line">vector&lt;int&gt; result(nums.size(), 0);</span><br><span class="line">for (int i = 0, j = nums.size() - 1; i &lt;= j;)</span><br><span class="line">&#123;</span><br><span class="line">if (nums[i] * nums[i] &lt; nums[j] * nums[j])</span><br><span class="line">&#123;</span><br><span class="line">result[k--] = nums[j] * nums[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">result[k--] = nums[i] * nums[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>此时的时间复杂度为O(n)，相对于暴力排序的解法O(n + nlog n)还是提升不少的。</p><h1 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4.运行结果"></a>4.运行结果</h1><p>测试代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nums6 = &#123; -5,-3,0,2,5,6 &#125;;</span><br><span class="line">void loop_traversal(vector&lt;int&gt; nums)</span><br><span class="line">&#123;</span><br><span class="line">auto pd = nums.begin();</span><br><span class="line">for (pd; pd != nums.end(); pd++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *pd &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void ordered_array_sorting_test()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;双指针解法&quot; &lt;&lt; endl;</span><br><span class="line">auto result=sortedSquares_duel_points(nums5);</span><br><span class="line">loop_traversal(result);</span><br><span class="line">cout &lt;&lt; &quot;暴力解法&quot; &lt;&lt; endl;</span><br><span class="line">auto result2 = sortedSquares_violent_solutions(nums6);</span><br><span class="line">loop_traversal(result2);</span><br><span class="line">cout &lt;&lt; &quot;nums6&quot; &lt;&lt; endl;</span><br><span class="line">loop_traversal(nums6);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">双指针解法</span><br><span class="line">0</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">25</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">暴力解法</span><br><span class="line">0</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">25</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">nums6</span><br><span class="line">0</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">25</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法</title>
      <link href="/2024/04/18/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
      <url>/2024/04/18/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-二分法概念"><a href="#1-二分法概念" class="headerlink" title="1.二分法概念"></a>1.二分法概念</h1><p>二分法（Bisection method），是一种一分为二的方法。对区[a,b]上连续不断且满足f(a)*f(b)&lt;0的函数y=f(x)，通过不断地把函数f(x)地零点所在区间的区间二分法，使区间两个端点逐步逼近零点，进而得到零点的近似值的方法。简而言之，就是不断缩小目标的所在区间，直到找到目标。<br>由于每轮可以排除一半的元素，因此最多循环logN次，时间复杂度O(logN)。<br>写二分法需要搞清楚一个区间问题，即在左闭右闭的时候，区间应该怎么处理，左闭右开，这时候又该怎么处理。本文将用c++代码书写该算法</p><h1 id="2-左闭右闭写法"><a href="#2-左闭右闭写法" class="headerlink" title="2.左闭右闭写法"></a>2.左闭右闭写法</h1><p>该c++代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int bisection_left_closed_right_closed(std::vector&lt;int&gt; &amp;nums, int target)</span><br><span class="line">&#123;</span><br><span class="line">int left = 0;</span><br><span class="line">int right = nums.size() - 1;//边界处理1</span><br><span class="line">int middle = 0;</span><br><span class="line">while (left &lt;= right)//边界处理2</span><br><span class="line">&#123;</span><br><span class="line">middle = (left + right) / 2;</span><br><span class="line">if (nums[middle] &gt; target)</span><br><span class="line">&#123;</span><br><span class="line">right = middle - 1;//边界处理3</span><br><span class="line">&#125;</span><br><span class="line">else if (nums[middle] &lt; target)</span><br><span class="line">&#123;</span><br><span class="line">left = middle + 1;//边界处理4</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return middle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>1.左闭右闭的边界处理1，为什么用nums.size()-1,而不用nums.size()呢？我们可以这样想nums.size()获取的值是数组的长度，该值比数组最大索引大1，由于是左闭右闭区间，这样就包括比索引大1的值，这是不合法的，所以应该去掉。<br>2.左闭右闭的边界处理2，为什么要用&lt;=,首先我们要看范围是否合法，我们用[1，1]举例，里面只有1这一个元素，若用&lt;，1&lt;1永不成立，根本无法进入循环。<br>3.左闭右闭的边界处理3，为什么要用right=middle-1,而不用middle呢？在该判断条件，我们已判断nums[middle]&lt;target了，这说明middle索引对应的值不为target，不是我们搜索的值，接下来的区间一定不包含这个值，所以right=middle-1。若写right=middle,那么下一个区间包含middle,而middle已确认不是target,放入下一个区间搜索循环，这样做边界处理有问题。<br>4.边界处理4与边界处理3一致，不再赘述。</p><h1 id="3-左闭右开写法"><a href="#3-左闭右开写法" class="headerlink" title="3.左闭右开写法"></a>3.左闭右开写法</h1><p>c++代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int bisection_left_closed_right_opened(std::vector&lt;int&gt; &amp;nums, int target)</span><br><span class="line">&#123;</span><br><span class="line">int left = 0;</span><br><span class="line">int right = nums.size();//边界处理1</span><br><span class="line">int middle = 0;</span><br><span class="line">while (left &lt; right)//边界处理2</span><br><span class="line">&#123;</span><br><span class="line">middle = (left + right) / 2;</span><br><span class="line">if (nums[middle] &gt; target)</span><br><span class="line">&#123;</span><br><span class="line">right = middle;//边界处理3</span><br><span class="line">&#125;</span><br><span class="line">else if (nums[middle] &lt; target)</span><br><span class="line">&#123;</span><br><span class="line">left = middle + 1;//边界处理4</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return middle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>1.对于边界处理1，这时为什么能用right=nums.size()呢？因为他是右开的区间，本身不包括右边界的值，故用right=nums.size()。<br>2.对于边界处理2，举个例子[1,1),这表示包括1，又不包括1，若用&lt;=，即1=1，与左闭右开区间相矛盾，故用&lt;。<br>3.对于边界处理3，nums[middle]&gt;target了，下一个搜索区间是不包括middle的，因为他是右开的区间，本身不包括右边界right，故可以用right=middle。<br>4.对于边界处理4，nums[middle]已经不等于target了，下一个搜索区间不包括middle,因为是左闭，所以要middle+1。</p><h1 id="4-算法的结果"><a href="#4-算法的结果" class="headerlink" title="4.算法的结果"></a>4.算法的结果</h1><p>使用如下代码得到结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; nums = &#123; 10,24,34,45,56,67,78,87,96,100 &#125;;</span><br><span class="line">void bisectiontest()</span><br><span class="line">&#123;</span><br><span class="line">int reason = bisection_left_closed_right_closed(nums, 24);</span><br><span class="line">if (-1 == reason)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没有找到目标值&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;找到值&quot; &lt;&lt; nums[reason] &lt;&lt; &quot;索引为&quot; &lt;&lt; reason &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">int reason1 = bisection_left_closed_right_opened(nums, 33);</span><br><span class="line">if (-1 == reason1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没有找到目标值&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到值&quot; &lt;&lt; nums[reason1] &lt;&lt; &quot;索引为&quot; &lt;&lt; reason1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到值24索引为1</span><br><span class="line">没有找到目标值</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组移除元素</title>
      <link href="/2024/04/18/%E6%95%B0%E7%BB%84%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2024/04/18/%E6%95%B0%E7%BB%84%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-要求"><a href="#1-要求" class="headerlink" title="1.要求"></a>1.要求</h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h1 id="2-双指针法"><a href="#2-双指针法" class="headerlink" title="2.双指针法"></a>2.双指针法</h1><p>双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。<br>1.快指针：寻找新数组的元素，新数组就是不含有目标元素的数组。<br>2.慢指针：指向更新新数组下标的位置。<br>快慢指针指向同一个地址。快慢指针先一起移动，若快指针找到要删除的值，慢指针停止移动，快指针继续移动，以此岔开快慢指针的位置，进入下一个循环，慢指针就会被快指针赋予下个位置的值，以此达到后续数据往前移动的效果。<br>代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">      int slowindex=0;</span><br><span class="line">      for(int fastindex=0;fastindex&lt;nums.size();fastindex++)</span><br><span class="line">      &#123;</span><br><span class="line">        if(val!=nums[fastindex])</span><br><span class="line">        &#123;</span><br><span class="line">             nums[slowindex++]=nums[fastindex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      return slowindex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种算法时间复杂度为O(n),空间复杂度为O(1)。</p><h1 id="3-暴力解法"><a href="#3-暴力解法" class="headerlink" title="3.暴力解法"></a>3.暴力解法</h1><p>用两层for循环一个for循环遍历数组元素 ，第二个for循环更新数组。<br>用i—，是因为，将后面元素覆盖到前面时，这个覆盖前面的元素可能也是要删除的元素，若不i—，则会错过该元素，例如[1,2,2,3],要删除2，下标为2的元素到前面了，此时i=1,若不i—,则i到下一个循环，值为2，而下个要删除的数在下标1那里，已经错过，无法删除。所以要i—。<br>代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int removeElement_Violent_solutions(vector&lt;int&gt;&amp; nums, int val)</span><br><span class="line">&#123;</span><br><span class="line">int size = nums.size();</span><br><span class="line">for (int i = 0; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (val == nums[i])//发现需要移除的元素，就将数组集体向前移动一位</span><br><span class="line">&#123;</span><br><span class="line">for (int j = i + 1; j &lt; size; j++)</span><br><span class="line">&#123;</span><br><span class="line">nums[j - 1] = nums[j];</span><br><span class="line">&#125;</span><br><span class="line">i--;//因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span><br><span class="line">size--;// 此时数组的大小-1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度：O(n^2)，空间复杂度：O(1)</p><h1 id="4。算法的结果"><a href="#4。算法的结果" class="headerlink" title="4。算法的结果"></a>4。算法的结果</h1><p>因为此算法得到的是数组长度，所以此处需要定义自己的遍历算法来接收数组长度，否则输入有误。<br>遍历代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void removeloop(vector&lt;int&gt;&amp; nums, int val)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; val; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>测试代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void removetest()</span><br><span class="line">&#123;</span><br><span class="line">int reason = removeElement_Dual_pointers(nums2, 3);</span><br><span class="line">removeloop(nums2, reason);</span><br><span class="line">cout &lt;&lt; &quot;********&quot; &lt;&lt; endl;</span><br><span class="line">int reason2 = removeElement_Violent_solutions(nums3, 3);</span><br><span class="line">removeloop(nums3, reason2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">********</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><br>为了验证没有i—时，算法无法删干净目标元素，特写以下代码进行试验<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nums4 = &#123;1, 2, 2, 3&#125;;</span><br><span class="line">int badremoveElement_Violent_solutions(vector&lt;int&gt;&amp; nums, int val)</span><br><span class="line">&#123;</span><br><span class="line">int size = nums.size();</span><br><span class="line">for (int i = 0; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (val == nums[i])</span><br><span class="line">&#123;</span><br><span class="line">for (int j = i + 1; j &lt; size; j++)</span><br><span class="line">&#123;</span><br><span class="line">nums[j - 1] = nums[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line">void removetest()</span><br><span class="line">&#123;</span><br><span class="line">int reason = removeElement_Dual_pointers(nums2, 3);</span><br><span class="line">removeloop(nums2, reason);</span><br><span class="line">cout &lt;&lt; &quot;********&quot; &lt;&lt; endl;</span><br><span class="line">int reason2 = removeElement_Violent_solutions(nums3, 3);</span><br><span class="line">removeloop(nums3, reason2);</span><br><span class="line">int reason3 = badremoveElement_Violent_solutions(nums4, 2);</span><br><span class="line">cout &lt;&lt; &quot;没有i--的暴力解法&quot; &lt;&lt; endl;</span><br><span class="line">removeloop(nums4, reason3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">********</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">没有i--的暴力解法</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">请按任意键继续. . .</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux入门</title>
      <link href="/2024/04/16/Linux/"/>
      <url>/2024/04/16/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="1-vi-vim编辑器"><a href="#1-vi-vim编辑器" class="headerlink" title="1.vi/vim编辑器"></a>1.vi/vim编辑器</h1><p>vi编辑器是Unix系统下的一款文本编辑器，而vim是vi improved的缩写，是vi编辑器的增强版，它们的使用方法是一样的，只是vim在vi的基础上，增加了一些新的功能和改进，使用起来更加地方便。在命令行中输入vi通常也会启动vim。<br>vi中有三种常用的模式，分别是<strong>命令模式（command mode）</strong>，<strong>插入模式(insert mode)</strong>，<strong>尾行模式(last line mode)</strong>,他们的关系及其快捷键如下图：<br><img src="https://pic-bed-1lf.pages.dev/imgmd/modes.png" alt="三种模式" title="三种模式"><br>进入到vim之后默认的是命令模式，在命令模式输入：进入尾行模式，在输入q退出vim编辑器。vim命令后可以加文件名，回车进入该文件，若没有该文件，则会创建新的文件进入。<br>示例命令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi hello.txt</span><br></pre></td></tr></table></figure><br>运行结果如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/openfile.png" alt="进入文件" title="进入文件"><br>命令模式进入插入模式的快捷键作用有些许不同。小写的i键和a键分别表示在光标的前面或者后面插入内容，大写的I键和O键表示在当前行的行首或者行尾来插入内容。小写o键表示在当前行的下一行插入内容，大写的O键在当前行的上一行插入内容。<br>编写完成后再尾行模式下输入以下命令保存退出文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wq</span><br></pre></td></tr></table></figure><br>输入以下命令查看当前目录文件和文件夹<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><br>使用cat命令查看文件内容，内容将出现在终端。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt</span><br></pre></td></tr></table></figure><br>使用vi命令进入文件后，可以使用<strong>hjkl</strong>这几个键控制光标的移动代表← ↓ ↑ → 。同时键盘的←，↓，↑，→也具有同样的功能。同时^键和$键分别表示光标跳转到这一行行首和行尾，当这一行的内容很长时，这两个快捷键很方便的。<br>在命令模式下，我们也可以用快捷键来执行复制、粘贴、删除等操作。连续按下两个y键来复制一行内容，在按下p键将复制的内容粘贴到下一行，每按下一次p键就会粘贴一次。连续按下两个d删除一行内容，同样可以使用p键将删除的内容粘贴到光标所在的下一行。与windows相比，可以说<strong>yy</strong>与<strong>ctrl+v</strong>,<strong>p</strong>与<strong>ctrl+v</strong>,<strong>dd</strong>与<strong>ctrl+x</strong>相同。还有一个小技巧，在快捷键前面加上一个数字，表示复制或者粘贴的次数，比如输入2yy就会复制两行内容，在输入一个3p,就会把刚刚复制的两行内容在下面粘贴三次。<br>vi内复制命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yy</span><br><span class="line">//复制n行</span><br><span class="line">nyy</span><br></pre></td></tr></table></figure><br>vi内粘贴命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">//粘贴n次</span><br><span class="line">np</span><br></pre></td></tr></table></figure><br>vi内删除命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd</span><br></pre></td></tr></table></figure><br>在尾行模式下输入<strong>set number</strong>或者其缩写<strong>set nu</strong>可以查看文件行号。如果不需要行号，就在尾行模式输入<strong>set nonumber</strong>关闭行号显示。<br>如果文件太长，慢慢向下翻，效率太慢。在这种情况下，我们可以使用<strong>ctrl+f</strong>和<strong>ctrl+b</strong>来快速地向前翻页或者向后翻页。或者使用<strong>ctrl+u</strong>和<strong>ctrl+d</strong>快速向下翻半页和向上翻半页。我们还可以使用大写的G跳转到文件最后一行，小写的gg跳转到文件的第一行。如果要跳转到文件中指定的某一行，就输入行号再按下大写字母G，比如输入100G跳转到100行。也可以输入一个冒号，再加上行号，比如：50回车跳转到第50行，也是一样的效果。<br>尾行模式下设置行号<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set number</span><br><span class="line">//取消行号</span><br><span class="line">set nonumber</span><br></pre></td></tr></table></figure><br>在vi中查找和替换也是非常常用的，我们可以使用斜线或者问号进行查找。在命令模式下输入一个<strong>斜线（/）</strong>，后面加上要找的内容，就会从光标所在的位置开始向下查找，向上查找就是用<strong>问号（？）</strong>。当我们找到目标后，如果需要查找下一个，就可以输入一个小写的<strong>n</strong>键。如果需要反向查找下一个，就输入大写的<strong>N</strong>键。查找是区分大小写的，如果需要不区分大小写，就需再次基础上输入\c，就不会区分大小写。或者在尾行模式下输入<strong>set ic(ignore case)</strong>同样达到效果。vi的替换需要输入命令:n1,n2s/old/new/g，其中，n1和n2表示范围，如果只是替换当前行只需忽略这两个数字，s表示替换的意思，old表示要替换的内容，new表示替换后的内容，g表示全局，如果不加g只会替换每一行的第一个匹配到的内容，加上g之后就会替换每一行的所有匹配到的内容。<br>vi内尾行模式查找命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//n向下找，N反之</span><br><span class="line">/内容</span><br><span class="line">//n向上找，N反之</span><br><span class="line">?内容</span><br></pre></td></tr></table></figure><br>vi内尾行模式替换命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//n1和n2表示范围，s为替换,g为全局，也就是设置这行所有匹配的内容，否则就替换第一个匹配内容，old需要替换的内容，new替换后的内容</span><br><span class="line">n1,n2s/old/new/g</span><br></pre></td></tr></table></figure><br>vi的撤销快捷键是u,与windows的ctrl+z一样。<br>在vi还有一个非常重要的文件.vimrc,这个文件可以保存vi的配置信息，我们可以设置一些快捷键或者插件等。这样以后打开vi就不需要每次手动设置了。</p><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h1><h2 id="1-ls命令"><a href="#1-ls命令" class="headerlink" title="1.ls命令"></a>1.ls命令</h2><p>ls(list)显示目录内容,查看当前目录下所有文件和文件夹。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><br>若需要查看更详细信息，可以输入命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><br>若需要查看隐藏文件在内的所有文件和目录，可以输入命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure><br>当然还有其他参数,-h可以以人类可读的方式显示文件的大小，-t可以安装修改时间排序，-r可以逆序显示等等，命令后面的参数可以组合使用。比如命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -h -t -r -l</span><br><span class="line">//以下也行</span><br><span class="line">ls -htrl</span><br></pre></td></tr></table></figure><br>运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/commandls.png" alt="ls命令" title="ls命令"></p><h2 id="2-ln命令"><a href="#2-ln命令" class="headerlink" title="2.ln命令"></a>2.ln命令</h2><p>观察上面的图，左边一列是文件的类型和权限，第一个字符表示文件的类型，中杠（-）表示普通文件，d表示目录，l表示链接文件。其中链接文件是linux系统中的特殊文件，它分为硬链接和软链接两种。软链接也叫符号链接，它类似于Windows系统中的快捷方式，文件名左边表示的是链接文件本身，右边用箭头指向的方式表示了它所指向的文件或者目录。创建链接文件的命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ln(link)创建链接文件</span><br><span class="line">ln -s hello.txt link.txt</span><br></pre></td></tr></table></figure><br>-s参数表示创建的是软链接文件，如果不加，默认硬链接文件。<br>运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/commandln.png" alt="ln命令" title="ln命令"><br>使用cat命令查看，他们的内容是一样的。软链接文件本身不存储文件内容，它只是一个指向目标文件的快捷方式。所有软链接文件大小非常小。<br>不加-s是硬链接，其本质是一个指向文件系统中另一个文件的指针，它与原始文件共享相同的i节点。<br>i节点详细如下图<br><img src="https://pic-bed-1lf.pages.dev/imgmd/inode.png" alt="i节点" title="i节点"><br>i节点是文件系统中一个非常重要的概念，在linux系统中，每个文件或者目录都有唯一一个i节点，它存储了文件的元数据信息，包括文件权限，所有者，大小，修改时间等，系统用过这个i节点识别文件的。硬链接文件和原始文件共享相同的i节点，也就意味着他们共享相同的文件内容。源文件和硬链接是文件系统中同一个文件的不同名字。<br>当我们删除其中一个文件时，另一个文件还是可以正常访问的。当我们把软链接的目标文件删除时，软链接文件就会失效。软链接和硬链接的另外一个区别是，软链接可以指向文件或者目录，但是硬链接只能指向文件，不能指向目录。</p><h2 id="3-chmod命令"><a href="#3-chmod命令" class="headerlink" title="3.chmod命令"></a>3.chmod命令</h2><p>左边9个字符表示权限。图解如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/authority.png" alt="权限图解" title="权限图解"><br>相应的位置上没有权限，就会显示一个中杠（-）<br>我们可以使用change mode命令修改文件的权限，+为添加权限，-为删除权限，比如添加一个可执行权限<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x hello1.txt</span><br></pre></td></tr></table></figure><br>运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/commandchmod.png" alt="添加执行权限" title="添加执行权限"><br>除了使用加号或者减号添加权限，还可以在加号和减号前面加上u、g或者o，来单独给文件所有者，同组或者其他用户添加或者删除权限。当然ugo可以组合使用。<br>还有其他更简单的方式修改权限，文件的权限由9个字符组成，每一组三个字符表示读、写和执行权限，我们可以把这三个字符分别用一个数字来表示，r表示4，w表示2，x表示1，再把他们加起来就可以得到这个组的权限数字。比如将下图的默认权限可以转换成644，6表示文件所有者同时具有读和写的权限，后面两个4表示同组或者其他用户只有读的权限。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/chmod1.png" alt="权限数字解读" title="权限数字解读"><br>用数字修改权限命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//所有用户都基于读写执行权限</span><br><span class="line">chmod 777 hello1.txt</span><br></pre></td></tr></table></figure><br>运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/commandchmod2.png" alt="数字权限运行图" title="数字权限运行图"></p><h2 id="4-touch命令和echo命令"><a href="#4-touch命令和echo命令" class="headerlink" title="4.touch命令和echo命令"></a>4.touch命令和echo命令</h2><p>创建文件有多种方式，除了可以用vi编辑器创建，还可以用touch创建，这个命令本身的作用是用来更新文件的修改时间的，如果文件不存在，就会创建一个新的空文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch hello.txt</span><br></pre></td></tr></table></figure><br>除了touch命令，还可以用echo命令。echo是一个输出文本的命令，例如以下命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello&quot;</span><br></pre></td></tr></table></figure><br>就可以再命令行中回显出我们输入的内容。<br>如果想把命令保存在一个文件的话，使用重定向符号（&gt;），后面加上文件名，将内容重定向到文件里。当文件不存在时，他就会自动创建一个文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello&quot; hello.txt</span><br></pre></td></tr></table></figure></p><h2 id="5-pwd命令和cd命令"><a href="#5-pwd命令和cd命令" class="headerlink" title="5.pwd命令和cd命令"></a>5.pwd命令和cd命令</h2><p>在window系统中，文件和目录是以盘符开始的，比如c盘d盘等，而在linux系统中，文件结构是一种树状结构，所有的文件都是从根目录开始的，根目录的符号是一个斜线（/），我们可以执行一个pwd命令，他的作用是显示当前所在目录的位置。也可以使用cd命令切换目录<br>pwd命令的使用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><br>cd命令的使用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//回到根目录下面</span><br><span class="line">cd /</span><br></pre></td></tr></table></figure></p><h2 id="6-cp命令"><a href="#6-cp命令" class="headerlink" title="6.cp命令"></a>6.cp命令</h2><p>复制命令是cp，用法是cp加上要复制的文件和复制后的文件名<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将file2文件复制一份</span><br><span class="line">cp file2.txt file3.txt</span><br></pre></td></tr></table></figure></p><h2 id="7-mv命令"><a href="#7-mv命令" class="headerlink" title="7.mv命令"></a>7.mv命令</h2><p>mv命令可以移动文件或者重命名文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//把file3重命名为file4</span><br><span class="line">mv file3.txt file4.txt</span><br></pre></td></tr></table></figure></p><h2 id="8-删除命令"><a href="#8-删除命令" class="headerlink" title="8.删除命令"></a>8.删除命令</h2><p>rm删除文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//删除file4</span><br><span class="line">rm file4.txt</span><br></pre></td></tr></table></figure></p><h2 id="9-mkdir命令"><a href="#9-mkdir命令" class="headerlink" title="9.mkdir命令"></a>9.mkdir命令</h2><p>mkdir创建目录<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建一个folder目录</span><br><span class="line">mkdir folder</span><br></pre></td></tr></table></figure><br>-p参数可以创建多级目录<br>比如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建多级目录</span><br><span class="line">mkdir -p folder1/folder2/folder3</span><br></pre></td></tr></table></figure></p><h2 id="10-du命令和tree命令"><a href="#10-du命令和tree命令" class="headerlink" title="10.du命令和tree命令"></a>10.du命令和tree命令</h2><p>du命令查看文件或者目录的结构和大小<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du</span><br></pre></td></tr></table></figure><br>专门显示目录结构的tree命令，以树状图的形式显示目录的结构，他不是linux自带的命令，需要使用包管理器安装。</p><h2 id="11-rmdir命令"><a href="#11-rmdir命令" class="headerlink" title="11.rmdir命令"></a>11.rmdir命令</h2><p>rmdir命令删除目录，如果目录下没有文件，就会直接删除，否则报错。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir folder</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="/2024/04/15/Docker/"/>
      <url>/2024/04/15/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1.Docker简介"></a>1.Docker简介</h1><p>Docker是一个用于<strong>构建</strong>、<strong>运行</strong>、<strong>传送</strong>应用程序的平台，有了Docker,我们可以将应用程序和它运行时所需要的各种依赖包、第三方软件库、配置文件等打包在一起，以便在任何环境中都可以正确地运行。</p><h1 id="2-为什么使用Docker"><a href="#2-为什么使用Docker" class="headerlink" title="2.为什么使用Docker"></a>2.为什么使用Docker</h1><p>举一个例子，写一个网站需要用前后端分离架构，前端使用Vue框架构建网站界面，后端使用JAVA中的SpringBoot微服务架构来提供各种服务和接口，使用MYSQL数据库存储数据。如果没有Docker,需要在本地安装NodeJS环境，各种npm依赖，JAVA运行时环境，各种第三方依赖等，才能让网站运行。并且将项目部署到测试环境或生产环境上，则需要在新的环境重复以上操作，这样浪费大量了的时间。有了Docker，就可以将上面的东西打包成一个个集装箱，只要在开发环境中运行成功，那么在其他环境也能运行成功。</p><h1 id="3-Docker和虚拟机的区别"><a href="#3-Docker和虚拟机的区别" class="headerlink" title="3.Docker和虚拟机的区别"></a>3.Docker和虚拟机的区别</h1><h2 id="1-虚拟机"><a href="#1-虚拟机" class="headerlink" title="1.虚拟机"></a>1.虚拟机</h2><p>VMware、vittalbox、paralels desktop、WSL等是常见的虚拟机软件。在上面运行的系统是完整的操作系统，和实际的Windows和Linux系统一样，可以在这个操作系统中运行应用程序。这是通过一种叫虚拟化（Hypervior）的技术来实现的。虚拟化技术是一种将物理资源虚拟为多个逻辑资源的技术，它可以将一台物理服务器虚拟成多个逻辑服务器，每个逻辑服务器都有自己的操作系统、cpu、内存、硬盘和网络接口等。他们之间是完全隔离的，可以独立运行。虚拟机一定程度上实现了资源的整合。可以将一台服务器的计算能力、存储能力、网络资源分配给多个逻辑服务器，实现多台服务器的功能。但是，它的缺点很明显，每台虚拟机都需要占用大量的资源，而且启动速度非常慢，通常需要几分钟甚至几十分钟。大部分情况下，我们的一台服务器上只需要运行一个主要对外提供服务的应用程序即可，并不需要一个完整的操作系统所提供的所有功能。拿刚刚的例子来说，我们只需要一个web服务器，而虚拟机要启动一个完整的操作系统，包括操作系统的内核，各种系统服务，各种工具，甚至图形化界面等等。这样我们并不需要的服务占用了大量的资源。导致了资源的浪费和启动速度慢的问题。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/virtual_machine.png" alt="虚拟机" title="虚拟机"></p><h2 id="2-Docker"><a href="#2-Docker" class="headerlink" title="2.Docker"></a>2.Docker</h2><p>Docker和容器是两个不同的概念，Docker只是容器的一种实现，是一个容器化的解决方案和平台。容器是一种虚拟化技术，和虚拟机类似，也是一个独立的环境，可以在这个环境中运行应用程序。和虚拟机不同的是，它并不需要在容器中运行一个完整的操作系统，而是使用宿主机的操作系统，所有启动速度非常快，通常只需要几秒，同时所需要的资源更少，可以在一台物理服务器上运行更多的容器，这样可以跟家充分的利用服务器的资源，减少资源的闲置和浪费。比如我们的一台物理服务器可能只能运行几个虚拟机，但是却可以运行上百个容器，这就是容器和虚拟机的主要区别。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/docker.png" alt="Docker" title="docker"></p><h1 id="4-基本原理和概念"><a href="#4-基本原理和概念" class="headerlink" title="4.基本原理和概念"></a>4.基本原理和概念</h1><p>先介绍Docker的镜像、容器和仓库。镜像是一个只读的模板，它可以用来创建容器，容器是Docker的运行实例，它提供了一个独立的可移植的环境，可以在这个环境中运行应用程序，镜像和容器的关系就像JAVA中的类和实例的关系一样，我们可以定义一个类中有哪些属性和方法，这个定义好的类就是一个模板，我们可以根据这个模板来创建多个实例，这些实例就是这个类的对象，对应到Docker中，镜像就是一个模板，容器就是这个模板的一个实例，可以有一个，也可以有多个。在举个生活的例子，镜像就像一个食谱，详细的描述了如何制作一道菜肴，容器就是根据食谱做出来的那道菜，你可以根据这个食谱做出很多到菜，但是这些菜都是根据同一个食谱做出来的，做出来的菜都是一样的。而且也可以把食谱分享给其他喜欢美食的朋友，那他也可以根据这个食谱做出一道一样的菜来，这就是镜像和容器的关系。食谱如何分享给别人呢，这就要看第三个概念————Docker仓库。<br>Docker仓库是用来存储Docker镜像的地方，最流行和最常用的仓库就是Dockerhub，它是一个公共的仓库，用来集中存储和管理Docker镜像，我们可以在这里下载各种镜像，也可以将自己的镜像上传到这里，这样就可以实现镜像的共享和复用，这也是Docker非常流行的一个原因。拿刚刚的例子来说，如果你发明了一道非常美味的菜肴，那么就可以把这个食谱放到Dockerhub上，这样其他人可以根据食谱做出一样的菜，这就是镜像的共享和复用。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/principleandconcept.png" alt="Docker" title="docker的基本原理和概念"><br>Docker是使用Client-Server架构模式，Docker Client和Docker Daemon之间通过socket或者RESTful API进行通信，Docker Daemon就是服务器的守护进程，他负责管理Docker的各种资源，Docker Client负责向Docker Daemon发生请求，Docker Daemon接收到请求之后进行处理，然后将结果返回给Docker Client，这里的Docker Daemon是一个后台进程，用来接收并处理来自Docker客户端的请求，然后将结果返回给客户端，所以我们在终端中输入的各种Docker命令，实际上都是通过Docker客户端，发送给Docker Daemon的，然后Docker Daemon进行处理，最后再将结果返回给客户端，然后就可以在客户端看到执行结果了。</p><h1 id="5-容器化和Dockerfile"><a href="#5-容器化和Dockerfile" class="headerlink" title="5.容器化和Dockerfile"></a>5.容器化和Dockerfile</h1><p>容器化（containerization），顾名思义就是将应用程序打包成容器，然后在容器中运行应用程序的过程。这个过程可以简单分成三部分:</p><ul><li><p>创建一个Dockerfile。来告诉Docker构建应用程序镜像所需要的步骤和配置。</p></li><li><p>使用Dockerfile构建镜像。</p></li><li><p>使用镜像创建个运行容器。</p></li></ul><p>什么是Dockerfile，Dockerfile是一个文本文件，里面包含了一条条指令，用来告诉Docker如何来构建镜像，这个镜像中包括了我们应用程序执行的所有命令，也就我们之前提到的各种依赖，配置环境，和运行应用程序所需要的所有内容，一般来说包括下面这些内容。精简版的操作系统，比如Alpine,应用程序的运行时环境，比如Nodejs,java,python,应用程序，比如SpringBoot打包好的jar包，应用程序的第三方依赖库或者包，应用程序的配置文件，环境变量等等。一般来说，我们会在根目录下创建一个叫Dockerfile的文件，在这个文件中写入构建镜像所需要的各种指令后，Docker就会根据这个Dockerfile文件来构建一个镜像，有了镜像后，我们就可以使用这个镜像来创建容器，然后在容器中运行应用程序。</p><h1 id="6-实践操作"><a href="#6-实践操作" class="headerlink" title="6.实践操作"></a>6.实践操作</h1><p>以下为简单的案例，实机演示一下编写Dockerfile,创建镜像，启动容器的过程。</p><h2 id="1-在桌面上创建一个文件夹HelloDocker"><a href="#1-在桌面上创建一个文件夹HelloDocker" class="headerlink" title="1.在桌面上创建一个文件夹HelloDocker"></a>1.在桌面上创建一个文件夹HelloDocker</h2><h2 id="2-然后使用VScode等编辑器打开这个文件夹"><a href="#2-然后使用VScode等编辑器打开这个文件夹" class="headerlink" title="2.然后使用VScode等编辑器打开这个文件夹"></a>2.然后使用VScode等编辑器打开这个文件夹</h2><h2 id="3-在文件夹中创建一个index-js文件"><a href="#3-在文件夹中创建一个index-js文件" class="headerlink" title="3.在文件夹中创建一个index.js文件"></a>3.在文件夹中创建一个index.js文件</h2><h2 id="4-在文件中输入一段代码-并在终端运行"><a href="#4-在文件中输入一段代码-并在终端运行" class="headerlink" title="4.在文件中输入一段代码,并在终端运行"></a>4.在文件中输入一段代码,并在终端运行</h2><p>nodejs是一个运行时环境，它可以让我们在浏览器之外的地方运行javascript代码，nodejs和javascript的关系和java和JRE的关系一样，如果想运行java程序，那么就需要安装JRE.所有我们想在另外一个环境中运行这个应用程序都需要执行哪些步骤呢。<br>首先我们在这个环境中安装操作系统。然后安装对应版本的javascript运行环境，也就是nodejs。再把应用程序和它所依赖的第三方包和库复制到这个环境上，最后执行命令运行程序有了Docker后，我们就可以把这些步骤写入Dockerfile中，剩下的工作交给Docker来自动完成。<br>下面的代码是在控制台打印文字<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;欢迎来到一小时Docker教程，拜托一键三连了&quot;)</span><br></pre></td></tr></table></figure><br>下面指令是在vscode终端执行index.js文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><br>终端运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/command1.png" alt="command1" title="node index.js的运行"></p><h2 id="5-在根目录创建一个Dockerfile的文件"><a href="#5-在根目录创建一个Dockerfile的文件" class="headerlink" title="5.在根目录创建一个Dockerfile的文件"></a>5.在根目录创建一个Dockerfile的文件</h2><p>主要第一个字母D要大写，否则无法识别。并且vscode下载Docker扩展。</p><h2 id="6-在Docker指定一个基础镜像"><a href="#6-在Docker指定一个基础镜像" class="headerlink" title="6.在Docker指定一个基础镜像"></a>6.在Docker指定一个基础镜像</h2><p>镜像是按层次结构构建的，每一次都是基于上一层的，所有我们需要先指定一个基础镜像，然后在这个基础上添加我们的应用程序。<br>下面代码是指定一个基础镜像<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM node:20-alpine</span><br></pre></td></tr></table></figure><br>20表示nodejs版本，alpine表示这个镜像是基于alpine这个linux发行版来构建的，alpine和其他我们经常听说的RedHat,Centos一样，都是一种linux发行版，只不过它是一个非常轻量级的linux发行版，体积非常小，只有几十M，所有下载和部署都非常快，配置完运行环境后，还需要把应用程序复制到镜像中。可以使用copy命令复制文件。<br>代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//COPY source destination</span><br><span class="line">COPY index.js /index.js</span><br></pre></td></tr></table></figure><br>然后运行应用程序，使用CMD命令运行，CMD第一个参数表示可执行程序的名字，第二个参数表示可执行程序接收到的参数。<br>代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;node&quot; ,&quot;/index.js&quot;]</span><br></pre></td></tr></table></figure><br>index.js所有代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM node:20-alpine</span><br><span class="line">COPY index.js /index.js</span><br><span class="line">CMD [ &quot;node&quot; ,&quot;/index.js&quot;]</span><br></pre></td></tr></table></figure></p><h2 id="7-构建镜像"><a href="#7-构建镜像" class="headerlink" title="7.构建镜像"></a>7.构建镜像</h2><p>到vscode终端使用docker build -t hello-docker .命令来构建镜像,.为Dockerfile所在目录<br>命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hello-docker  .</span><br></pre></td></tr></table></figure><br>终端运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/command2.png" alt="command2" title="镜像的构建"><br>使用docker image ls命令来查看我们所有的镜像，我们可以在控制台看到我创建的镜像。<br>命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><br>终端运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/command3.png" alt="command3" title="查看镜像"></p><h2 id="8-运行"><a href="#8-运行" class="headerlink" title="8.运行"></a>8.运行</h2><p>使用docker run hello-docker命令,hello-docker为刚刚构建的镜像名字<br>命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-docker</span><br></pre></td></tr></table></figure><br>终端运行图如下<br><img src="https://pic-bed-1lf.pages.dev/imgmd/command4.png" alt="command4" title="运行"><br>在控制台中出现了我们输入的内容，说明应用程序已经运行起来了。如果想在另一个环境中运行这个应用程序，那么就只需要把这个镜像文件复制过去，然后执行上面的命令即可。也可以把镜像文件上传到Dockerhub或者Harbor镜像仓库中，这样任何人都可以在任何地方使用docker pull命令下载这个镜像，然后运行这个应用程序。</p><h1 id="7-Docker-Desktop"><a href="#7-Docker-Desktop" class="headerlink" title="7.Docker Desktop"></a>7.Docker Desktop</h1><h2 id="1-images界面"><a href="#1-images界面" class="headerlink" title="1.images界面"></a>1.images界面</h2><p>点击镜像（images）后，可以看到镜像的名称、标称、状态等信息，点击播放按钮可以使用这个镜像运行一个容器了，也就相当于在终端执行docker run命令。后面三个小点表示更多操作，点击后弹出一个菜单。第一项查看这个镜像包的详细信息，第二和第三项是镜像的远程仓库相关操作，也就是从远程仓库拉取镜像或者推送镜像到远程仓库中，这两个功能需要登录账号。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/image_operate.png" alt="images" title="images界面"></p><h2 id="2-containers界面"><a href="#2-containers界面" class="headerlink" title="2.containers界面"></a>2.containers界面</h2><p>点击容器（containers）后，与镜像一样，可以查看容器的信息，操作与镜像基本一致。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/containers.png" alt="containers" title="containers界面"></p><h2 id="3-volumes界面"><a href="#3-volumes界面" class="headerlink" title="3.volumes界面"></a>3.volumes界面</h2><p>逻辑卷界面，逻辑卷是Docker中用来存储数据的，Docker容器有一个特点，就是容器中的数据不会持久化的，当我们创建一个容器的时候，它通常已一个干净的文件系统开始，容器启动后，我们可以在容器中创建文件，修改文件，但是容器停止后，容器中的所有数据都会丢失掉，如果我们想持久化容器中的数据，就需要依靠逻辑卷。它可以把容器中的目录或者指定路径映射到宿主机的某一个目录或者位置上，这样就可以将数据保存带宿主机的磁盘上，实现数据的持久化。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/Volumes.png" alt="volumes" title="volumes界面"></p><h2 id="4-Dev-Environments-BETA"><a href="#4-Dev-Environments-BETA" class="headerlink" title="4.Dev Environments BETA"></a>4.Dev Environments BETA</h2><p>该界面用来管理开发环境的，我们可以在这创建一个开发环境，然后使用一些代码来配置这个开发环境，这样就可以把这个开发环境共享给项目中的其他开发人员，让每一个人在同一个环境下进行开发。避免环境不一致导致的各种问题。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/dev_environments.png" alt="Dev Environments BETA" title="dev_environments界面"></p><h2 id="5-Learning-Center"><a href="#5-Learning-Center" class="headerlink" title="5.Learning Center"></a>5.Learning Center</h2><p>官方提供的学习视频和教程。</p><h2 id="6-Add-Extensioning"><a href="#6-Add-Extensioning" class="headerlink" title="6.Add Extensioning"></a>6.Add Extensioning</h2><p>可以安装一些扩展来增强它的功能。<br><img src="https://pic-bed-1lf.pages.dev/imgmd/add_extensions.png" alt="add_extensioning" title="add extensioning界面"></p><h1 id="8-Docker-Compose"><a href="#8-Docker-Compose" class="headerlink" title="8.Docker Compose"></a>8.Docker Compose</h1><p>Docker Compose是由Docker官方开源的项目，是一个用来定义和运行多容器Docker应用程序的工具。比如之前搭建网站的案例，可能会使用前端、后端、数据库甚至缓存、负载均衡等多个服务器。这些服务都是独立的，但是之间又有关联，需要相互配合来工作，Docker Compose通过一个单独的docker-compose.yaml的配置文件，来将这一组互相关联的容器组合在一起，形成一个项目，然后使用一条命令启动、停止或者重建这些服务，这样就可以非常方便的管理这些服务了。举个例子，假如项目组中来了一个新同事，之前可能需要半天时间安装各种依赖和配置运行环境，有了Docker Compose后，只需要执行docker compose up命令，就可以自动安装各种依赖和配置运行环境。然后再本地运行项目了。</p><p>本文根据youtube平台，GeekHour教程所写，域名为<a href="https://www.youtube.com/watch?v=Ozb9mZg7MVM，访问请">https://www.youtube.com/watch?v=Ozb9mZg7MVM，访问请</a> <a href="https://www.youtube.com/watch?v=Ozb9mZg7MVM" title="30分钟Docker入门教程">点击此处</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><div class="note default simple"><p>内容…….</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第五篇文章"><a href="#这是我的第五篇文章" class="headerlink" title="这是我的第五篇文章"></a>这是我的第五篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第三篇文章"><a href="#这是我的第三篇文章" class="headerlink" title="这是我的第三篇文章"></a>这是我的第三篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第二篇文章"><a href="#这是我的第二篇文章" class="headerlink" title="这是我的第二篇文章"></a>这是我的第二篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第二篇文章"><a href="#这是我的第二篇文章" class="headerlink" title="这是我的第二篇文章"></a>这是我的第二篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四篇文章</title>
      <link href="/2024/04/13/2024-4-13-%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/04/13/2024-4-13-%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第四篇文章"><a href="#这是我的第四篇文章" class="headerlink" title="这是我的第四篇文章"></a>这是我的第四篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
